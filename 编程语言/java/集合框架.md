---
tags:
  - java
---
**# 一. 包装类

| 基本类型      | 包装类         |
| --------- | ----------- |
| `byte`    | `Byte`      |
| `short`   | `Short`     |
| `char`    | `Character` |
| `int`     | `Integer`   |
| `long`    | `Long`      |
| `float`   | `Float`     |
| `double`  | `Double`    |
| `boolean` | `Boolean`   |

基本类型在栈上,
引用类型在堆上.

Java 8 之后有了 **IntStream、DoubleStream** 这类“专门处理基本类型”的集合流


功能上的区别

| 基本类型     | 包装类            |
| -------- | -------------- |
| 只能存值     | **有方法可用**      |
| 不可为 null | 可表示“缺失值(null)” |
| 不可用在泛型   | 可用于集合、泛型等      |
==拓展 — 包装类有缓存机制==
`Integer a = 100; Integer b = 100; System.out.println(a == b);   // true (缓存)  Integer c = 200; Integer d = 200; System.out.println(c == d);   // false (不缓存)`

✅ -128 ~ 127 范围内，`Integer.valueOf()` 会缓存实例，避免重复创建


# 二.数组
引用数据类型
## 1. 定义:
	是一种容器,可以用来存储同种数据类型的多个值

**存储时要结合隐式转换**
eg:int类型的数组可以存放byte,short,int类型数据

## 2. 数据的初始化
### 2.1 静态初始化

`int[] array = new int[]{11,22,33};`
简写:
`int[] array = {11,22,33};

### 2.2 动态初始化
	初始化时只指定数组长度,由系统为数组分配初始值
格式: 数据类型[] 数组名 = new 数据类型[数据长度];


## 3.二维数组
格式:
`数据类型[][] arr = new 数据类型[][]{{元素...},{元素...}};`

简化:
`数据类型[][] arr = {{元素...},{元素...}};`

动态初始化:
格式:
`数据类型[][] arr = new 数据类型[m][n];`


# 三. 集合
## 集合体系结构
![[file-20251112170515665.png]]

List系列集合:有序,可重复,有索引
Set系列集合: 无序,不可重复,无索引

## 泛型
泛型的通配符
![[file-20251112170515803.png]]
![[file-20251112170515856.png]]


## 单列集合Collection
>[CollectionAPI](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collection.html)

单列集合的祖宗接口
![[file-20251112170515943.png]]
使用contains时,若是自定义对象,要重写equals方法


Conllection通用的遍历方法
- 迭代器遍历
![[file-20251112170516054.png]]  迭代器会检查modCount(操作次数)检查是否与expectedModCount一致,如果不一致,则迭代器失效(Fail-fast)

- 增强for循环
使用范围:单列集合和数组
```java
for(String s: coll){
//s为每次迭代的对象
	Systecm.out.println(s);
}
```

- Lambda表达式遍历
```java
default void forEach(Consumer<? super T> action):
```
![[file-20251112170516112.png]]
Consumer为函数式接口,可以用匿名内部类或lambda来使用

List:
![[file-20251112170516181.png]]
### List
>[ListAPI](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/List.html)

添加的有关索引的方法
![[file-20251112170516265.png]]
ListIterator接口继承Iterator接口,同时添加了新的方法(能够添加元素)
![[file-20251112170516319.png]]



#### 1. Arraylist
>[ArraylistAPI](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/ArrayList.html)

==底层为数组==

扩容机制:
1. 刚开始是0
2. 添加后为10
3. 往后的每次扩容为原容量的1.5倍

成员方法
```java
boolean add(E e)          //添加元素
boolean remove(E e)       //删除指定元素,返回值表示是否删除成功
E remove(int index)       //删除指定索引的元素,返回被删除的元素
E set(int index,E e)      //修改指定索引下的元素,返回原来的元素
E get(int index)          //获取指定索引的元素
int size()                //集合的长度,也就是集合中元素的个数
```

#### LinkedList
>[LinkedListAPI](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/LinkedList.html)

==底层为双链表==
提供了操作首尾元素的API
![[file-20251112170516417.png]]

### Set
无序,不重复,无索引
![[file-20251112170516476.png]]


#### HashSet
采用哈希表存储数据
![[file-20251112170516525.png]]

![[file-20251112170516608.png]]

#### TreeSet
![[file-20251112170516661.png]]

自定义排序规则
![[file-20251112170516728.png]]

![[file-20251112170516838.png]]

## 双列集合Map
>[MapAPI](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Map.html)

![[file-20251112170516898.png]]
Map
![[file-20251112170517002.png]]

Map的遍历方法
1. 键找值
2. 键值对
3. Lambda表达式
![[file-20251112170517086.png]]

![[file-20251112170517157.png]]

![[file-20251112170517298.png]]

#### HashMap
![[file-20251112170517408.png]]

#### LinkedHashMap
![[file-20251112170517515.png]]

#### TreeMap
![[file-20251112170517567.png]]

# 可变参数
![[file-20251112170517669.png]]
![[file-20251112170517725.png]]

# Collections
 >[API](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/util/Collections.html)
 
 ![[file-20251112170517799.png]]


# 不可变集合
![[file-20251112170517879.png]]

# Stream流

获取Stream流
![[file-20251112170518032.png]]

中间方法
![[file-20251112170518087.png]]

终结方法
![[file-20251112170518197.png]]

