---
tags:
  - java
---
>主要记录内容
>1. 继承
>2. 多态
>3. 类与对象
>4. static
>5. final
>6. 权限
>7. 抽象类
>8. 接口

# 一. 基本数据类型和引用数据类型
## 1. 基本数据类型
 - 整数类型
 - 浮点数类型
 - 布尔类型
 - 字符类型

## 2. 引用数据类型
**特点:**
	在堆中开辟一个空间
	储存的是其他空间的地址值


# 二. 继承

关键字==extends==: 
	 **建立起==继承==关系**
``` title:示例
public class Student extends Person {}
```

## 1. 特点
1. ==单继承==
2. ==多层继承==
3. 每个类都直接或间接的==继承于Object==,如果没有自己继承,jvm会自动继承Object
4. ==子类==只能访问==父类==中==非私有==的成员


## 2. 继承内容
继承:
 - 成员变量
 - 虚方法

不继承:
 - 构造方法

**注意**:
1. ==private成员变量==继承,但是只有父类给了set/get方法才能调用
2. 虚方法: 非private 非static 非final

## 3. 成员方法的访问特点:
1. 就近原则
2. super直接调用父类

## 4. 构造方法的访问特点

- 子类中所有的构造方法默认先访问父类中的无参构造,再执行自己.
	- why?
		- 子类在初始化时,可能会使用父类的数据,如果父类没有完成初始化.子类将无法使用父类的数据
		- 子类初始化之前,一定要调用父类构造方法先完成父类数据空间的初始化
	- how?
		- 子类构造方法的第一句默认都是super(),不写也存在,且必须在第一行
		- 如果想调用父类的有参构造,必须手动写super进行调用

# 三. 多态
==同类型的对象,表现出的不同形态==

``` title:表现形式:
父类类型 对象名称 = 子类对象;
```

前提: 
 - 有继承关系
 - 有父类引用指向子类对象
 - 有方法重写

好处:
  使用父类型作为参数,可以接收所有子类对象,体现多态的扩展性与便利

## 1. 调用成员的特点
- java中只会让你调用100%确定的方法,所以在多态中,只能调用父类的成员变量和成员方法,==编译时只要在父类中存在就可以成功编译==
- 方法调用为运行时绑定,执行时,JVM看对象实际类型,按照正常子类来运行,所以会直接运行子类重写的方法

## 2. 优势和弊端

 **优势**:
1. 在多态形式下,右边对象可以实现解耦合,便于扩展和维护
2. 在定义方法的时候,使用父类型作为参数,可以接受所以子类对象,体现多态的扩展性与便利

**弊端**:
-  不能调用子类的特有功能(特有的成员变量和方法)
	==解决方案:强制转化为子类的类型,就可以正常调用了==
```java
 animal a1 = new Dog();    // 向上转型隐式进行
if (a1 instanceof Dog) {  // 对象 instanceof 类型
    Dog d = (Dog) a1;     // ai为dog类型的,d为a1的引用，并没有开辟新的空间，只是改变了标识，让编译器认为d为dog类型
    d.bark();
}
```
新特性:
	可以直接判断并且强转
```java
animal a1 = new Dog();    
if (a1 instanceof Dog d) {  //在后面直接接上变量d
    d.bark();
}****
```

# 四. 类与对象
## 1. 定义类
 ```java
 public class 类名{
	 1. 成员变量(属性)
	 2. 成员方法(行为)
	 3. 构造器
	 4. 代码块
	 5. 内部类
 }
```

 ```
//获得类的对象
类名 对象名 = new 类名();

//使用对象
对象名.成员变量
对象名.方法名(...)

 ```

**类的分类**
 - javabean类:(用来描述一类事物的类,不写main)

	- 类名---见名知意
	- 成员变量----private
	- 构造方法---至少两个
	  - 无参构造方法
	  - 带全部参数的构造方法
	- 成员方法
	  - 提供每一个成员变量对应的setXxx()/getXxx()
	  - 如果还有其他行为,也需要写上

 - 测试类:
	- 创建javabean类的对象并进行赋值调用(写main方法)

- 工具类:
	1. 类名见名知意
	2. ==私有化==构造方法
	3. 方法定义为==静态==
	 (不描述任何事物)


## 4. 构造方法的格式  

**作用:**
	在创建对象时给成员变量初始化
```java
修饰符 类名(参数){
	方法体;
}
```
  特点:
   1. 方法名和类名完全相同
   2. 没有返回值类型,包括void
   3. 没有具体的返回值(不能由return带回来结果数据)
## 5. 注意事项
1. 不写时,虚拟机自动调用无参构造
2. 如果定义了构造方法,则系统不再提供默认构造





## 7. FAQ
1. 成员变量可以赋初值,但一般不初始化,直接为默认值

# 五. STATIC

static:(**静态关键词**)
   **修饰成员方法和成员变量**
 
## 静态变量
 
 **类变量**:被该类的所有对象共享

### 调用方法:
  - 类名调用
  - 对象名调用(不推荐)

### 内存图

当.class文件加载到方法区后,在内存中创建一个单独存放静态变量的空间(静态区)
JDK8以前,静态区在方法区内
JDK8以后就挪到了堆空间中

==JVM加载.class文件时，会在Java堆中生成对应的Class对象。==
==该Class对象内部包含指向元空间中「类元数据」的指针，而类元数据中包括static变量的存储空间。==
==因此，**static变量实际存储在元空间，Class对象仅间接引用它们**。==

注:
	静态变量是随类加载而加载的,优于对象出现

## 静态方法
特点:
  - 多在测试类和工具类中
  - Javabean类中很少会用

调用方法:
  - 类名调用
  - 对象名调用

## 注意事项
- 静态方法只能访问静态变量和静态方法
- 非静态方法可以访问静态变量或者静态方法,也可以访问非静态的成员变量和非静态的成员方法
- **静态方法中没有this关键字**

# 六.FINAL
修饰后:
1. 类:表明该类是最终类,不能被继承
2. 变量:叫做常量,只能被赋值一次(可以不在定义时赋值)
3. 方法:表明该方法为最终方法,不能被重写

**命名规则**:
- 全部大写,多单词间用_隔开

细节:
- 修饰的变量是基本类型:变量储存的数据值不能发生改变
- 修饰的变量是引用类型:记录的地址值不能改变,内部的属性可变

字符串为==private,final==修饰,因此不能修改地址值,并且在外部无法修改字符串内容

# 七.抽象类
将多个类的共性部分抽象出来成为抽象类

定义格式
```java
public abstract class 类名{
	//成员变量
	//成员方法(有方法体)
	//抽象方法(不写方法体)
	//构造方法
	int var;
	public void fun(){方法体};
	public abstract 返回值类型 方法名(参数);
	类名{构造方法};
}
```
**注意**:
- 抽象方法必须写在抽象类中
- 抽象类不能实例化
- 子类--满足其一
  - 实现抽象方法
  - 也是抽象类

# 八.接口
将多个类中的共性方法抽象出来成为接口

定义格式
```java
public interface 接口名{}

//实现接口
public class 类名 implements 接口名{
//抽象方法(public abstract),默认,可省略前缀
//默认方法(default)
//静态方法(static)
//私有方法(private)
//常量(public static final),默认
	void fly(); //抽象方法
	default void land(){方法体};
	static void info(){方法体};
	private void helper(){方法体};
	int MAX_SPEED =100; //前缀可省略(必须初始化)
}
```
注意:
- 接口不能实例化
- 子类--满足其一
  - 重写接口中的所有抽象方法
  - 抽象类

# 九.代码块
- 局部代码块
	- 提前结束变量的生命周期
- 构造代码块
	- 提取构造函数的公共部分
	- 创建类对象时,先执行构造代码块,再执行构造函数
- 静态代码块
	- `static{}`
	- 随着类加载而执行,只执行一次

# 十.内部类
- 成员内部类
```java title:创建成员内部类
//1.外部类提供内部类的方法
//2.直接创建
Outer.Inner oi = new Outer().new Inner();
```
![[file-20251112170518377.png]]
- 静态内部类
![[file-20251112170518496.png]]
- 局部内部类 ![[file-20251112170518548.png]]
- 匿名内部类
	- ![[file-20251112170518638.png]]

# 十一. Lambda表达式
![[file-20251112170518691.png]]

![[file-20251112170518787.png]]

![[file-20251112170518843.png]]

# 十二. 权限
## 权限修饰符

![[file-20251112170518930.png]]

## 包
包名的规则:
- 公司域名反写+包的作用(需要全部英文小写,见名知意)

全类名:
`package com.moningf.myclass`

- 使用其他包的规则:
	- 使用同一个包中的类时,不需要导包
	- 使用java.lang包中的类时,不需要导包
	- 其他情况都需要导包
	- 如果同时使用两个包中的同名类,需要用全类名


# 十三.反射
![[file-20251112170518982.png]]
## 获取Class对象
```java
1. Class.forname("全类名");
2. 类名.class
3. 对象.getClass();  
```
## 获取构造方法
![[file-20251112170519100.png]]
## 获取成员变量
![[file-20251112170519152.png]]
## 获取成员方法
![[file-20251112170519239.png]]


   
# 十四. Java的对象内存图
## 1. 介绍Java内存分配
jdk7之前:
1. 栈
2. 堆
3. 方法区
4. 本地方法栈
5. 寄存器

注:
1. 堆和方法区为一片连续的空间


jdk8改进后
取消了方法区,新增了元空间. 把原来方法区的多种功能进行拆分,有的功能放到了堆中,有的功能放到了元空间中.

运行类时,.class文件会进入方法区,方法运行时进入的内存变量在栈空间
new的东西会在堆中开辟空间并产生地址

## 2. 一个对象的内存图
`Student s = new Student();`
1. 加载class文件
2. 申明局部变量
3. 在堆内存中开辟一个空间
4. 默认初始化
5. 显示初始化
6. 构造方法初始化
7. 将堆内存中的地址值赋值给左边的局部变量

### 2.1 两个对象的内存图
注:
	class文件只用加载一次(加载到方法区)
	在堆中,存储的是对象的成员变量,和成员方法的地址(在方法区)

### 2.2 两个引用指向同一个对象
第二个对象没有在堆中开辟空间,直接赋值的第一个对象的地址 

在赋值完成之后:
当第一个对象是null时,则第二个对象仍然指向的堆中的地址,仍然能继续操作

# 十五. 方法引用
使用条件:
1. 参数为函数式接口
2. 引用的函数和原来的返回值和参数,参数类型都一样

类型:
1. 类的成员方法
2. 类的静态方法
3. 类的构造方法
4. 特殊的引用
5. 数组构造引用

语法:
```java
假设现有一个函数的参数为函数式接口
@FunctionalInterface
interface MyPrinter {
    void print(String s);
}

# 类的成员方法
MyPrinter p = this::func       //本类
MyPrinter p = super::func        //父类
MyPrinter p = 类对象::func         //其他类

# 类的静态方法
MyPrinter p = 类名::func

# 类的构造函数
MyPrinter p = 类名:new  //前提是函数式接口的返回值为该类

# 特殊调用
MyPrinter p = (a,b) - > a.equil(b)
MyPrinter p = a的类名::equil        //这个为第一个参数为调用者

# 数组构造引用
MyPrinter p = Integer[]::new
```

# 十六. 异常
异常体系
Throwable
->Error/ Exception
-> RuntimeException/其他

异常的方法
```java
public String getMessage()
public String toString()
public void printStackTrace()
```

# I/O

## File类
常见方法:
![[image.png]]

![[image-1.png]]

![[image-2.png]]

![[image-3.png]]

## OutputStream/InputStream
内部有FileOutStream/FileInputstream

## Reader/Writer
内部有FileReader/FileWriter

其中FileReader是通过字符来读取的(并且他有8192字节的数组为缓冲区)


## 缓冲流 Buffered*
缓冲流->相对于File\*流 多了缓冲区
```java
BufferedReader = new BufferReader(new FileReader)
```
BufferedReader流构造时需要传入Reader流参数
该流同时提供了newline(),readline()方法(其他Buffered流没有该方法)


## 转换流
OutputStreamWriter流和InputStreamReader流
他们的构造方法需要传入OutputStream或者InputStream流,同时可以传入参数==编码格式==

作用: 将字节流转换为字符流(同时能定义它的编码格式)GBK or UTF-8

历史:
	它的出现是为了解决字节流无法正确读取多字节字符编码问题,而FileReader则是对它的封装,使其更加的方便使用

扩展: 
	对于InputStreamReader流来说,可以通过BufferedReader进行进一步封装,可以提高性能,同时使用BufferedReader特有的方法

## 序列化流

```java
ObjectInputStream(InputStream)
ObjectOutputStream(OutputStream)
```

方法:
```java
writeObject()
readObject()
```

使用条件:实现Serializable接口(标记性接口)

修改类后,反序列化冲突(因为SerialVersionUID不一致):
	需要手动固定private static final long SerialVersionUID = \*\*\*;

如果不想让某个属性参与序列化:
	可以通过transient关键字(瞬态关键字)赋给某个属性即可

## 打印流
字节打印流:PrintStream
字符打印流:PrintWriter

字节打印流没有缓冲区,字符打印流有缓冲区

## 解压缩流
```java

//解压
ZipInputStream unzip = new ZipInputStream(new FileInputStream(File));
ZipEntry entry = unzip.getZipEntry();
通过unzip.read()命令可以获取解压缩文件的字节流

//压缩
ZipOutputStream zip = new ZipOutputStream(new FileOutputStream(new File("a.zip")));
ZipEntry zipfile = new ZipEntry("a.zip");
zip.putNextEntry(zipfile);
zip.write(); //write命令可以通过读取某个文件,然后传入

FileInputStream fis=new FileInputStream(file);
int len;byte[] buf=new byte[1024];  
while((len = fis.read(buf)) != -1){  
    zip.write(buf,0,len);  
}
fis.close();
zip.closeEntry();
zip.close();
```

## 与IO有关的工具包

Commons-io
![[image-4.png]]

Hutool工具包
![[image-5.png]]
[文档](https://doc.hutool.cn/)

