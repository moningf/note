# 一. 变量与常量
## 1. 变量

用法：
	数据类型 变量名 = 数值名


| 整数类型  | 浮点数    | 字符   | 布尔      |
| ----- | ------ | ---- | ------- |
| long  | float  | char | Boolean |
| short | double |      |         |
| byte  |        |      |         |

细节:
	1.变量名不可重复
	2.变量使用前要赋值
	3.一个语句可以定义多个变量
	4.在定义long类型时,数据值以L或者l作为后缀
	5.在定义float类型时,数据值以F或者f作为后缀
	
## 2. 特殊字符
### 制表符\t
\t
在打印时,把前面的字符串的长度补齐到8,或者8的倍数.
	最少补1个空格,最多补8个空格
	
	- 基本用法
		`System.out.println("tom" + \t + "23")`
	- 注意事项
		它是补齐前面的内容

## 3. 字面量
- 整数类型
- 小数类型
- 字符串类型
- 字符类型
	char
- 布尔类型
	boolean
- 空类型 'null'
	null 不能直接被打印

# 二. 方法
方法是程序中最小的执行单元.
## 1. 定义和调用
1. 最简单的方法定义和调用
```java
public static void 方法名(){
 方法体;
}
```
调用:
`方法名();`

2. 带参数的方法的定义和调用
```java
public static void method(int num1,int num2){
	方法体;
}
```
调用:
`method(10,120);`

3. 带返回值的方法的定义和调用
```java
public static int method(){
	方法体;
	return 返回值;
}
```
调用:
 method();
 int result = method();


## 2. 方法的重载
在同一个类中,定义了多个同名的方法,每个方法都有不同的参数类型和参数个数,这些同名的方法就构成了重构关系
**简:**
1. 方法名相同
2. 在同一个类中
3. (与返回值无关)
4. 参数不同:
	- 个数不同
	- 类型不同
	- 顺序不同

## 3. 方法的重写
当父类的方法不能满足子类现在的需求时,需要进行方法重写

### 3.1 书写格式
在继承体系中,子类出现了和父类中一模一样的方法声明,我们称这个方法是重写的方法

### 3.2 @Override 重写注解
1. @Override是放在重写后的方法上,检验子类重写时语法是否正确
2. 加上注解后如果有红色波浪线,表示语法错误
3. 建议重写方法都加@Override注解,代码安全,优雅

### 3.3 方法重写的本质
在继承过程中,覆盖了虚方法表中的方法

### 3.4 方法重写的注意事项和要求
1. 重写方法的名称,形参列表必须与父类中的一致
2. 子类重写父类方法时,访问权限子类必须大于等于父类(空着不写<protected<public)
3. 子类重写父类方法时,返回值类型子类必须小于等于父类 
4. ==建议:重写的方法尽量和父类保持一致==
5. 只有被添加到虚方法表中的方法才能被重写

# 三. 分支结构

## 1. if语句
```java
if(关系表达式){
		语句体;
	}
	else if(关系表达式){
		语句体;
	}
	...
	else{
		语句体;
	}
```
## 2. switch语句
```java
switch(表达式) {
	case 值1:
		语句体;
		break;
	
	case 值2:
		语句体;
		break;
	
	case 值3:
		语句体;
		break;
	...
	defalut:
		 语句体;
		 break;
}
```

在jdk12之后优化了switch语句
```java
switch(语句体){
	case 1 -> {
		语句体;
	}
	case 2,3-> {             //case里面可以写多个要匹配的值,(上一个写法也行)
		语句体;
	}
	case 4 -> 语句体;        //括号可以省略
	
	default -> {
		语句体;
	}
}
```
注意:
	如果没有break,那么case就会继续执行,导致case穿透,知道遇到break才会结束

# 四. 控制语句
## 1. break语句
结束整个循环

## 2. continue语句
结束当前循环,继续下一次循环

# 五. 循环语句

## 1. do...while循环
```java
初始化语句;
do{
循环体语句;
条件控制语句;
}while(条件判断语句);
```

## 2. for循环
```java
for(int i = 1;i<=10;i++){
	System.out.println("hello");
}	
```

## 3. while循环
```java
初始化语句;
while(条件判断语句){
	循环体语句;
	条件控制语句;
}
```

# 六. 运算符

## 1. 算术运算符
	1. +
	2. -
	3. *
	4. /
	5. %


- 字符串相加
	'+'不再是算术运算符,会将前后的数据进行拼接,并产生一个新的字符串

- 字符相加
	字符+字符 / 字符+数字 时,会把字符通过ASCII码表查询到对应数字再进行计算



## 2. 自增运算符
	1. j++ //先用再加
	2. ++j //先加再用


## 3. 赋值运算符
	1. +=   将左右相加,然后把结果赋值给左边
	2. -=   同上
	3. [*=] 同上
	4. /=   同上
注意:
	扩展的赋值运算符隐含了强制的类型转换

## 4. 关系运算符
1. ==
2. !=
3. >
4. <
5. >=
6. <=
注意关系运算符的返回值为boolean类型


## 5. 逻辑运算符
1. &        并且,两边都为真,才为真
2. |        或,两边都为假,才为假
3. ^        异或, 相同为真,不同为假
4. !        取反
---短路逻辑运算符
5. &&   短路与
6. ||   短路或

## 6. 三元运算符
语法:
`关系表达式 ? 表达式1 : 表达式2;`

注意:
	三元运算符的值必须被使用

## 7. 运算符的优先级

()优先于所有运算符

## 8. 隐式转换和强制转换

###  8.1隐式转换(取值范围小的转化为大的)
	1. byte , short , chat类型的数据在运算时会自动转化为int类型再进行运算
	2. 取值范围小的转化为大的,再进行运算
	
	eg:
	`int a = 10;`
	`double b =100;1
	`a+b;`  //会自动提升为double类型


### 8.2 强制转换(取值范围大的转化为小的)
语法:
`数据类型 变量名 = (数据类型) 变量名;`
eg:
	`int a = 100;`
	`byte b = (byte) a;`

# 七. 原码和补码
原码与补码与反码均为8位bit
在计算中都是以补码的形式来计算的

## 1. 原码
定义:
	十进制数据的二进制表现形式,最左边为符号位,0为正,1为负
弊端:
	负数的计算+1,结果确实-1,由此提出了反码

## 2. 补码
定义:
	正数的补码是其本身,负数的补码是在其反码的基础上+1
由来:
	由于在计算中,0的反码有两种,因此,需要将负数0的反码+1,使其只有一个

正因为+1,导致-127为1000 0001,多出一个1000 0000,将其定义为-128
所以范围为[-128,127]

## 3. 反码
定义:
	正数的补码反码就是其本身,负数的反码是符号位保持不变,其余位取反
由来:
	是为了解决原码不能计算负数的问题
弊端:
	当计算跨0时,计算结果会少1,因为0有两个反码,由此出现了补码

## 4. 其他运算符
1. &     //逻辑与,运算规律:0为false,1为true
2. |     //逻辑或,运算规律:0为false,1为true
3. <<    //左移,向左移动,低位补0
4. >>    //右移,向右移动,高位补0或1,根据原来是正数还是负数
5. >>>   //无符号右移,向右移动,高位补0
eg:
```
int a =100;
a = (a >> 2);  //即位a向右移两位
```