---
tags:
  - sql
---
### 1.数据、数据库、数据库管理系统、数据库系统的概念

1. 数据：数据库处理的基本对象，是描述事物的符号记录，包括数字、文字、图像、音频等可被计算机识别和存储的信息。

2. 数据库：按照一定数据模型组织、存储和管理的结构化数据集合，是数据的 “容器”。

3. 数据库管理系统：用于管理数据库的软件系统，是用户与数据库之间的接口，负责数据库的建立、运行和维护。
4. 数据库系统：由数据库、数据库管理系统、应用程序、数据库管理员（DBA）和硬件环境组成的完整系统，是数据库应用的实际运行环境。

### 2.数据库系统的特点

1. 数据结构化

​	数据不再是孤立的零散记录，而是按统一的数据模型（如关系模型）组织，形成结构化的集合。

​	例如考试系统的试题数据，会按 “题干、选项、分值、科目” 等字段分类存储，不同表（如试题表、考生表）间通过关联关系（如考生 ID）建立联系，便于统一管理和查询。

2. 高共享性与低冗余度

​	数据集中存储并支持多用户、多应用共享访问，避免了传统文件系统中 “一个应用一套数据” 的重复存储问题。

​	例如考试试题数据库可同时支撑考生答题、教师阅卷、管理员统计等多个场景，同一道试题仅存储一次，大幅降低数据冗余。

3. 数据独立性高

​	数据独立性分为物理独立性和逻辑独立性，核心是数据与应用程序分离。

​	物理独立性：数据的存储结构（如存储位置、存储方式）改变时，无需修改应用程序；逻辑独立性：数据的逻辑结构（如字段增减、表关系调整）改变时，应用程序可通过调整接口继续使用，降低维护成本。

4. 统一管理与控制

​	由数据库管理系统（DBMS）统一负责数据的存取、安全、完整性校验等操作。

​	包含三大核心控制功能：数据安全性控制（防止非法访问）、数据完整性控制（保证数据合法）、并发控制（避免多用户同时操作导致数据冲突）。

5. 数据可恢复性

​	借助备份机制和日志文件，数据库系统能在故障（如硬件损坏、误操作）后恢复数据。

​	例如考生答题时系统崩溃，可通过日志恢复未提交的答题记录，避免数据丢失，保障考试正常进行。

### 3.数据库管理系统的功能

数据定义、数据操纵、数据控制、数据库维护、数据存储管理 五大核心功能

### 4.实体、实体型、实体集、实体之间的联系

1. 实体（Entity）

​	定义：现实世界中客观存在、可被区分的具体事物或概念，是数据库存储和描述的对象。

​	核心特征：具有明确的标识，能与其他事物区分开。

​	示例：单个考生、一道考试试题、一门课程，都是具体的实体。

2. 实体型（Entity Type）

​	定义：对同一类实体共同特征的抽象描述，通常用 “实体名 + 属性集” 来表示。

​	作用：作为数据库表的设计依据，属性对应表中的字段。

​	示例：“考生（学号，姓名，性别，考试科目）”“试题（试题 ID，题干，选项，分值，难度）”，都是实体型。

3. 实体集（Entity Set）

​	定义：同一实体型所对应的全部实体的集合，即具有相同属性的所有具体事物的总称。

​	对应关系：实体集在数据库中直接对应一张表，表中的每一行数据就是一个实体。

​	示例：所有参加本场考试的考生构成 “考生实体集”，所有考试试题构成 “试题实体集”。

4. 实体之间的联系（Relationship）

​	定义：不同实体集之间的关联关系，反映现实中事物的相互依存或关联逻辑。

常见类型及示例：

1. 一对一联系（1:1）：一个实体集中的每个实体，与另一个实体集中的一个实体唯一关联。比如 “考生” 与 “准考证”，一个考生对应一张准考证，一张准考证只属于一个考生。
2. 一对多联系（1:N）：一个实体集中的某个实体，与另一个实体集中的多个实体关联。比如 “考试科目” 与 “试题”，一门科目可包含多道试题，一道试题只属于一门科目。
3. 多对多联系（M:N）：两个实体集中的多个实体可相互关联。比如 “考生” 与 “试题”，一个考生要答多道试题，一道试题会被多个考生作答（需通过中间表 “答题记录” 实现关联）。

### 5.数据模型的三要素

1. 数据结构

​	定义：描述数据的组织形式，包括数据本身的类型、属性，以及数据之间的关联关系。

​	核心作用：确定数据的存储结构和逻辑关系，是数据模型的基础。

​	示例：关系模型中，数据结构表现为 “表”，表中的 “字段”（属性）定义数据类型（如 INT、VARCHAR），表与表之间通过 “主键 - 外键” 建立关联。

2. 数据操作

​	定义：对数据模型中存储的数据可执行的操作集合，以及操作的规则和效果。

​	常见操作：核心包括查询（SELECT）、插入（INSERT）、更新（UPDATE）、删除（DELETE），部分模型还支持统计、关联等复杂操作。

​	作用：明确用户和应用程序如何与数据交互，是数据模型的 “动作接口”。

3. 数据完整性约束

​	定义：确保数据模型中数据的准确性、一致性和有效性的规则集合，防止非法数据进入系统。

​	常见约束：包括实体完整性（主键唯一非空）、参照完整性（外键关联有效）、域完整性（数据类型 / 范围合法）、用户定义完整性（业务规则）。

​	作用：为数据划定 “合法边界”，是数据质量的保障。

### 6.数据库系统的三级模式结构

1. 外模式（External Schema）—— 用户视图

​	定义：也称子模式或用户模式，是数据库用户看到和使用的局部数据逻辑结构与特征。

​	核心特点：一个数据库可以有多个外模式，每个用户 / 应用程序对应一个或多个外模式，仅展示其所需的数据，屏蔽无关信息。

​	示例：考生登录考试系统后，仅能看到 “试题、答题界面、个人成绩” 相关数据（外模式），看不到后台的用户权限表、试题分类表等其他数据。

2. 模式（Schema）—— 全局逻辑视图

​	定义：也称概念模式，是数据库中全体数据的逻辑结构和特征的总描述，是所有用户视图的统一综合。

​	核心特点：一个数据库只有一个模式，它独立于外模式和内模式，是数据库的核心与基础。

​	示例：考试系统的模式包含 “考生表、试题表、答题记录表、成绩表” 等所有表结构，以及表之间的关联关系（如考生表与答题记录表通过学号关联）。

3. 内模式（Internal Schema）—— 存储视图

​	定义：也称存储模式，是数据物理结构和存储方式的描述，记录数据在磁盘上的实际存储位置、存储格式（如索引结构、数据压缩方式）等。

​	核心特点：一个数据库只有一个内模式，直接与硬件存储交互，屏蔽底层存储细节。

​	示例：考试试题数据在磁盘上按 “B + 树索引” 存储，答题记录按 “分区表” 存储在不同磁盘分区，这些都属于内模式的设计范畴。

------

两级映像的作用（保障数据独立性）

1. 外模式 - 模式映像：建立外模式与模式的对应关系，当模式（如试题表新增 “难度系数” 字段）修改时，只需调整该映像，无需修改用户应用程序，实现**逻辑数据独立性**。
2. 模式 - 内模式映像：建立模式与内模式的对应关系，当内模式（如存储方式从机械硬盘改为 SSD、索引结构调整）修改时，只需调整该映像，模式和外模式无需变动，实现**物理数据独立性**。

### 7.数据与程序的逻辑独立性、物理独立性

1. 逻辑数据独立性

​	定义：当数据库的**模式（全局逻辑结构）** 发生变化时，应用程序无需修改仍可正常运行。

​	实现原理：通过 “外模式 - 模式映像” 保障。模式修改后，只需调整该映像，使外模式（用户视图）保持不变，应用程序基于外模式编写，因此不受影响。

​	示例：考试系统的模式中，给 “试题表” 新增 “命题人” 字段（逻辑结构变化），考生对应的外模式（仅包含题干、选项、分值）未变，考生答题的应用程序无需修改，仍能正常访问试题。

2. 物理数据独立性

​	定义：当数据库的**内模式（物理存储结构）** 发生变化时，应用程序和模式均无需修改。

​	实现原理：通过 “模式 - 内模式映像” 保障。内模式修改后，调整该映像使模式保持不变，外模式依赖模式，因此应用程序不受影响。

​	示例：考试试题的存储介质从机械硬盘改为 SSD，或索引结构从 B + 树改为哈希索引（物理存储变化），模式中的 “试题表” 结构未变，考生访问试题的程序无需任何调整。

### 8.关系的完整性概念、应用

​	关系的完整性是指关系模型中数据必须满足的约束条件，本质是通过规则限制无效数据的录入、修改或删除，确保关系（数据库表）中数据符合现实逻辑和业务需求。

应用：实体完整性，参照完整性，用户定义完整性

### 11.基本表、视图的概念、区别

基本表：也称基表，是数据库中直接存储数据的物理表，是数据库的核心存储对象。

视图：是基于一个或多个基本表（或其他视图）的虚拟表，本身不存储数据，仅存储查询定义（SQL 语句）。

### 12.什么是数据库的安全性

数据库安全性是指通过一系列技术、策略和机制，防范对数据库的未授权访问、数据泄露、恶意修改、删除等风险，同时保障数据库服务持续稳定运行，确保数据的机密性、完整性和可用性。

### 13.实现数据库安全性控制的常用方法和技术

身份认证与访问控制， 数据加密技术， 防攻击技术， 审计与日志监控，数据备份与恢复，环境与系统安全

### 14.会用Grant和Revoke授权、收回权限

```sql
GRANT 权限列表 ON 数据库对象 TO 用户/角色 [WITH GRANT OPTION];
```

```sql
REVOKE 权限列表 ON 数据库对象 FROM 用户/角色;
```


### 15.为维护数据库完整，数据库管理系统必须能够实现的功能
#### 1. 支持完整性约束的定义与存储

- 允许用户通过 SQL 语句（如 CREATE TABLE、ALTER TABLE）定义实体完整性、参照完整性、用户自定义完整性（如取值范围、格式约束）。
- 将约束规则存储在数据字典中，作为后续检查的依据。

#### 2. 完整性检查功能

- 对数据库操作（插入、修改、删除）自动触发约束检查，验证操作是否符合预定义规则。
- 检查时机包括操作执行时（即时检查）或事务提交时（延迟检查），确保数据在任何状态下都符合完整性要求。

#### 3. 违约处理功能

- 当操作违反完整性约束时，执行预设的处理策略，如拒绝操作、回滚事务、触发级联操作（如级联更新 / 删除）。
- 向用户返回明确的错误提示，说明违约原因，方便问题排查。

#### 4. 完整性约束的维护与修改

- 支持用户通过 SQL 语句修改或删除已定义的完整性约束，适应业务需求的变化。
- 确保约束修改过程中不破坏现有数据的完整性，必要时自动检查历史数据是否符合新约束。

### 16. 实体完整性、参照完整性的违约处理

核心结论：实体完整性违约直接拒绝操作，参照完整性违约分情况处理以平衡数据一致性与可用性。

#### 实体完整性违约处理

- 主键值为空或重复时，数据库直接**拒绝插入或修改操作**，确保主键唯一标识实体。

#### 参照完整性违约处理

- 插入 / 修改外键：外键值无对应主键值时，拒绝操作；或采用 “级联更新 / 删除”“设为 NULL”（外键允许 NULL 时）。
- 删除主键：若有外键引用，拒绝删除；或级联删除外键对应的记录，或设外键为 NULL。

---

### 17. 函数依赖下主码及范式分析

核心结论：主码是唯一决定所有属性的最小属性集，范式需按 “1NF→2NF→3NF→BCNF” 逐级判断，核心是消除数据冗余和异常。

#### 主码分析步骤

1. 找出所有候选码（能唯一确定关系中所有属性的最小属性集）。
2. 从候选码中任选一个作为主码。

#### 范式判断规则

1. 1NF：属性不可再分（原子性），是最基础要求。
2. 2NF：满足 1NF，且消除部分函数依赖（非主属性完全依赖于主码）。
3. 3NF：满足 2NF，且消除传递函数依赖（非主属性不依赖于其他非主属性）。
4. BCNF：满足 3NF，且消除主属性对候选码的部分 / 传递依赖（所有函数依赖的左部都是候选码）。

---

### 18. 语义驱动的函数依赖与范式分析

核心结论：函数依赖源于业务语义，范式分析需结合语义明确依赖关系，再按规则判断。

#### 函数依赖提取

- 从业务场景中提炼属性间的必然联系，比如 “学生学号→学生姓名”“课程号→课程学分”。
- 区分完全 / 部分依赖、传递依赖，比如 “学号 + 课程号→成绩” 是完全依赖，“学号→成绩”（若一个学生只修一门课）是部分依赖。

#### 范式分析逻辑

1. 基于提取的函数依赖确定主码（候选码）。
2. 按 1NF→2NF→3NF→BCNF 的顺序逐一验证，判断是否存在对应异常（插入、删除、更新异常）。

---

### 19. 数据库设计步骤及功能

核心结论：数据库设计分 6 步，从需求到实现逐步落地，确保设计符合业务需求且高效可用。

1. 需求分析：收集业务需求，明确数据范围、处理逻辑、约束条件，输出需求规格说明书。
2. 概念结构设计：将需求转化为独立于 DBMS 的概念模型（E-R 图），明确实体、属性、关系。
3. 逻辑结构设计：将 E-R 图转换为 DBMS 支持的数据模型（如关系模型），进行模型优化（范式提升）。
4. 物理结构设计：确定存储结构（如索引、分区）、存取路径、存储分配，提升查询性能。
5. 数据库实施：创建数据库、表、视图、索引等对象，导入测试数据，编写应用程序。
6. 数据库运行与维护：监控性能、优化 SQL、备份恢复数据、处理故障，保障长期稳定运行。

---

### 20. 概念结构设计中实体与属性的划分原则

核心结论：实体是独立存在的对象，属性是实体的特征，划分核心是 “属性不可再分、实体可独立标识”。

1. 实体原则：能独立存在、可被唯一标识（有候选码），且与其他对象有明确关系，比如 “学生”“课程”。
2. 属性原则：
    - 原子性：属性不可再分，比如 “地址” 拆分为 “省、市、区” 更合理。
    - 依附性：属性不能脱离实体独立存在，比如 “成绩” 必须依附于 “学生” 和 “课程”。
    - 非关系性：属性不能是另一个实体，比如 “教师” 不能作为 “课程” 的属性，应设为独立实体并建立关联。

---

### 21. 各子系统 E-R 图的冲突类型

核心结论：E-R 图冲突主要分 3 类，需统一规范后才能合并为全局 E-R 图。

1. 命名冲突：同一对象在不同子系统命名不同（如 “客户” vs “用户”），或同一名称代表不同对象。
2. 属性冲突：同一属性的类型、长度、取值范围不一致（如 “年龄” 在 A 子系统为整数，B 子系统为字符串）。
3. 结构冲突：同一对象在不同子系统中要么是实体要么是属性，或实体间关系类型不一致（如 A 子系统中 “学生 - 课程” 是多对多，B 子系统是一对多）。

---

### 22. 事务及事务的特征

核心结论：事务是数据库操作的最小逻辑单元，具有 ACID 四大特征，保障数据一致性。

#### 事务定义

- 数据库中一系列不可分割的操作集合，要么全部执行成功，要么全部执行失败（回滚），比如 “转账”（扣款 + 到账）。

#### 事务的 ACID 特征

1. 原子性（Atomicity）：事务是不可分割的工作单元，操作要么全做，要么全不做。
2. 一致性（Consistency）：事务执行前后，数据库数据从一个一致状态变为另一个一致状态（如转账前后总金额不变）。
3. 隔离性（Isolation）：多个事务并发执行时，彼此隔离，一个事务的中间结果不影响其他事务。
4. 持久性（Durability）：事务提交后，修改永久保存，即使系统故障也不会丢失。

---

### 23. 故障分类及恢复方法

核心结论：故障分三类，恢复核心是 “冗余数据 + 日志文件”，不同故障恢复策略不同。

#### 故障分类

1. 事务故障：事务执行中因逻辑错误（如主键冲突）或系统错误导致未完成，需回滚。
2. 系统故障：硬件故障、软件崩溃等导致系统停止，未提交事务需回滚，已提交事务需确保持久化。
3. 介质故障：磁盘损坏等存储介质故障，数据丢失风险最高，需依赖备份恢复。

#### 恢复方法

1. 事务故障恢复：通过日志文件执行 “撤销（UNDO）”，将事务恢复到执行前状态。
2. 系统故障恢复：
    - 撤销未提交事务（UNDO）。
    - 重做已提交但未写入磁盘的事务（REDO）。
3. 介质故障恢复：
    - 先还原最新的数据库备份。
    - 再通过日志文件重做备份后提交的事务，恢复到故障前状态。

---

### 25. 并发操作带来的数据不一致性

核心结论：并发操作若不控制，会导致 4 类数据不一致，需通过隔离机制解决。

1. 丢失修改：两个事务同时修改同一数据，后提交的事务覆盖先提交的结果（如 A、B 同时修改同一商品库存，均从 100 减 10，最终应为 80 却成 90）。
2. 不可重复读：同一事务内多次读取同一数据，因其他事务修改并提交，导致读取结果不一致。
3. 脏读：一个事务读取了另一个事务未提交的修改（如 A 转账给 B，B 读取到未提交的到账金额，后 A 回滚，B 读取的是 “脏数据”）。
4. 幻读：同一事务内多次执行同一查询，因其他事务插入 / 删除数据，导致返回的记录数不一致。

---

### 26. 封锁及封锁类型、相容性

核心结论：封锁是并发控制的核心技术，通过限制事务对数据的操作权限避免不一致，有两种核心类型且存在明确相容性规则。

#### 封锁定义

- 事务对数据操作前，先向系统申请封锁，获得权限后再操作，防止其他事务干扰。

#### 封锁类型

1. 共享锁（S 锁，读锁）：事务仅读取数据，允许其他事务加 S 锁，但禁止加排他锁。
2. 排他锁（X 锁，写锁）：事务修改数据（增删改），禁止其他事务加任何锁（S 锁或 X 锁）。

#### 封锁相容性（“Y” 表示可共存，“N” 表示不可共存）

| 当前锁 \ 请求锁 | 共享锁（S） | 排他锁（X） |
| --------- | ------ | ------ |
| 共享锁（S）    | Y      | N      |
| 排他锁（X）    | N      | N      |
|           |        |        |

---

### 27. 三级封锁协议的定义及判断

核心结论：三级封锁协议通过逐步增强封锁规则，解决不同程度的数据不一致问题，级别越高一致性越强。

#### 三级封锁协议定义

1. 一级封锁协议：事务修改数据前加 X 锁，直到事务结束（提交 / 回滚）释放。解决 “丢失修改”。
2. 二级封锁协议：在一级基础上，事务读取数据前加 S 锁，读完后立即释放。解决 “丢失修改” 和 “脏读”。
3. 三级封锁协议：在一级基础上，事务读取数据前加 S 锁，直到事务结束释放。解决 “丢失修改”“脏读” 和 “不可重复读”。

#### 判断方法

- 看事务对读 / 写操作的锁类型及释放时机，匹配上述协议规则即可判定对应的封锁级别。

---

### 28. 死锁的诊断和解除

核心结论：死锁是事务间循环等待资源导致的僵持状态，需通过诊断发现、强制解除。

#### 死锁诊断

1. 资源分配图法：构造 “事务 - 资源” 有向图，若图中存在环路，则发生死锁。
2. 超时法：事务等待时间超过阈值，判定为死锁。

#### 死锁解除

1. 选择牺牲品：挑选代价最小的事务（如执行时间短、修改数据少）作为牺牲品。
2. 撤销事务：强制回滚牺牲品事务，释放其占用的锁，让其他事务继续执行。

---

### 29. 并发调度的可串行性

核心结论：可串行性是并发调度的正确性准则，指并发执行的结果与某一串行执行结果一致。

1. 串行调度：多个事务按先后顺序依次执行，无并发冲突，结果一定正确。
2. 并发调度：多个事务交替执行，需满足可串行性才是正确的。
3. 判断方法：通过 “冲突可串行化” 判断，若调度的冲突操作（对同一数据的读写、写写操作）可调整为串行顺序，则具有可串行性。
 
---

### 30. 两段锁协议及判断

核心结论：两段锁协议是保证并发调度可串行性的重要规则，分为 “加锁段” 和 “解锁段” 两个阶段。

#### 两段锁协议定义

1. 第一阶段（加锁段）：事务只能申请锁，不能释放锁（可多次加 S 锁或 X 锁）。
2. 第二阶段（解锁段）：事务只能释放锁，不能申请锁（释放后不可再加任何锁）。

#### 判断方法

- 检查事务的所有操作：是否存在 “先加锁后解锁”，且解锁后无新的加锁操作，满足则符合两段锁协议。
- 注意：两段锁协议能保证可串行性，但可能导致死锁。